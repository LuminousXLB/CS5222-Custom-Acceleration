\section{Matrix Multiplication Pipeline Optimization in HLS}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Understanding the baseline matrix multiply (background)}\label{sec:1a}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For Vitis 2020.2, the command used should be
\begin{minted}{console}
    $ vitis_hls -f hls.tcl
\end{minted}
The report generated by HLS (as in \autoref{rpt:float_00_orig}) shows that
some pipelining has already been done automatically by Vitis HLS.
In order to prepare baseline for the next part, I disabled the pipelining.

\inputminted{diff}{program/float_nopipe.diff}

The new report is as \autoref{rpt:float_01_nopipe}.
It turns out that the overall performance is a little bit worse than documented.
This is because every iteration in L3 loop takes 11 cycles and thus
2816 cycles in total to perform a single inner product.


\begin{figure}
    \inputminted[firstline=25,lastline=48]{text}{report/float_00_orig.rpt}
    \caption{Performance estimates in default condition}
    \label{rpt:float_00_orig}
\end{figure}


\begin{figure}
    {
        \subcaption{Performance Estimates}
        \inputminted[firstline=25,lastline=52]{text}{report/float_01_nopipe.rpt}
    }
    {
        \subcaption{Utilization Estimates}
        \inputminted[firstline=59,lastline=88]{text}{report/float_01_nopipe.rpt}
    }

    \caption{HLS Report with pipelining explicitly disabled}
    \label{rpt:float_01_nopipe}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pipelining in HLS (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The work is done with auto pipelining disabled.



\begin{sidewaystable}[p]
    \centering
    \caption{HLS Report for \texttt{mmult\_float}}\label{tab:float}
    \input{report/summary.tex}
\end{sidewaystable}

\subsubsection{Pipelining the L3 (innermost) loop}\label{sec:1bL3}

The code is modified as \autoref{fig:float-diff.L3}.

\begin{figure}[h!]
    \centering
    \inputminted{diff}{program/diff.L3}
    \caption{Inserting HLS directive for L3.}\label{fig:float-diff.L3}
\end{figure}

Pipelining the intermost loop do not trigger loop unrolling,
and thus the structure of 3-layer loops is not modified.
The loop body of L3 is pipelined, which reduces its latency
from 2816 cycles to 1031 cycles.
The initiation interval achieved of L3 is 4 cycles.

This design utilizes slightly more resources but no more floating point
adders or multipliers.


\subsubsection{Pipelining the L1 (outermost) loop}\label{sec:1bL1}

The code is modified as \autoref{fig:float-diff.L1}.

\begin{figure}[h!]
    \centering
    \inputminted{diff}{program/diff.L1}
    \caption{Inserting HLS directive for L1.}\label{fig:float-diff.L1}
\end{figure}


160 adders and 160 multipliers.

299.1 seconds

\subsubsection{Pipelining the L2 loop}\label{sec:1bL2}

The code is modified as \autoref{fig:float-diff.L2}.

\begin{figure}[h!]
    \centering
    \inputminted{diff}{program/diff.L2}
    \caption{Inserting HLS directive for L2.}\label{fig:float-diff.L2}
\end{figure}

16 adders and 16 multipliers.

62.45 seconds

Report
\begin{enumerate}
    \item the design latency in cycles,
    \item the overall device utilization (as Total per Resource),
    \item the number of floating point adders and multipliers
          (you can find this information under the Instance section of the synthesis report) and
    \item the Initiation Interval of the loops you pipelined.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C. Increasing Pipeline Parallelism by Repartitioning Memories (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report
\begin{enumerate}
    \item the design latency in cycles,
    \item the overall device utilization (as Total per Resource),
    \item the number of floating point adders and multipliers (you can find this information under the Instance section of the synthesis report) and
    \item the Initiation Interval of the loops you pipelined.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D. Amortizing Iteration Latency with Batching (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report \begin{enumerate}
    \item the design latency in cycles, and
    \item the overall device utilization (as Total per Resource).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{E. Extending Batch Size with Tiling (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report \begin{enumerate}
    \item the design latency in cycles, and
    \item the overall device utilization (as Total per Resource).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{F. Hardware compilation and FPGA testing on the PYNQ (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report
\begin{enumerate}
    \item the measured speedup and
    \item measured classification accuracy.
\end{enumerate}


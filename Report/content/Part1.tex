\section{Matrix Multiplication Pipeline Optimization in HLS}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A. Understanding the baseline matrix multiply (background)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The report generated by HLS (as in \autoref{rpt:float_00_orig}) shows that
some pipelining has already been done automatically by Vitis.
In order to prepare for the next part,
I disabled the pipelining.

\inputminted{diff}{program/float_nopipe.diff}

The new report is as \autoref{rpt:float_01_nopipe}.
It turns out that the overall performance is a little bit worse than documented.
This is because every iteration in L3 loop takes 11 cycles and thus
2816 cycles in total to perform a single inner product.


\begin{figure}
    {
        \subcaption{Performance Estimates}
        \inputminted[firstline=25,lastline=48]{text}{report/float_00_orig.rpt}
    }
    {
        \subcaption{Utilization Estimates}
        \inputminted[firstline=55,lastline=84]{text}{report/float_00_orig.rpt}
    }
    \caption{HLS Report in default condition}
    \label{rpt:float_00_orig}
\end{figure}


\begin{figure}
    {
        \subcaption{Performance Estimates}
        \inputminted[firstline=25,lastline=52]{text}{report/float_01_nopipe.rpt}
    }
    {
        \subcaption{Utilization Estimates}
        \inputminted[firstline=59,lastline=88]{text}{report/float_01_nopipe.rpt}
    }

    \caption{HLS Report with pipelining explicitly disabled}
    \label{rpt:float_01_nopipe}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{B. Pipelining in HLS (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report
\begin{enumerate}
    \item the design latency in cycles,
    \item the overall device utilization (as Total per Resource),
    \item the number of floating point adders and multipliers (you can find this information under the Instance section of the synthesis report) and
    \item the Initiation Interval of the loops you pipelined.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C. Increasing Pipeline Parallelism by Repartitioning Memories (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report
\begin{enumerate}
    \item the design latency in cycles,
    \item the overall device utilization (as Total per Resource),
    \item the number of floating point adders and multipliers (you can find this information under the Instance section of the synthesis report) and
    \item the Initiation Interval of the loops you pipelined.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{D. Amortizing Iteration Latency with Batching (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report \begin{enumerate}
    \item the design latency in cycles, and
    \item the overall device utilization (as Total per Resource).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{E. Extending Batch Size with Tiling (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report \begin{enumerate}
    \item the design latency in cycles, and
    \item the overall device utilization (as Total per Resource).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{F. Hardware compilation and FPGA testing on the PYNQ (8 marks)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Report
\begin{enumerate}
    \item the measured speedup and
    \item measured classification accuracy.
\end{enumerate}
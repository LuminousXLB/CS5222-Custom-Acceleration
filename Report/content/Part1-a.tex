%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Understanding the baseline matrix multiply (background)}\label{sec:1a}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For Vitis 2020.2, the command used should be
\begin{minted}{console}
    $ vitis_hls -f hls.tcl
\end{minted}
The report generated by HLS (as in \autoref{tab:float-loop-1a-baseline-autopipe}) shows that some pipelining has already been done automatically by Vitis HLS.
After inspecting the migration guide, I added two lines in the \texttt{hls.tcl}:
\begin{minted}{tcl}
    config_compile -pipeline_loops 0
    set_clock_uncertainty 12.5%
\end{minted}

The performance and utilization estimates of the two profiles, together with those for the following profiles, are reported in \autoref{tab:float-summary}.
The new loop details is as \autoref{tab:float-loop-1a-baseline-nopipe}.
It turns out that the overall performance is a little bit worse than documented.
This is because every iteration in L3 loop takes 11 cycles and thus
2816 cycles in total to perform a single inner product.

\begin{table}
    \caption{Loop details for baseline with automatic pipelining}
    \label{tab:float-loop-1a-baseline-autopipe}
    \centering
    \input{report/float-loop-1a-baseline-autopipe.tex}
\end{table}

\begin{table}
    \caption{Loop details for baseline without automatic pipelining}
    \label{tab:float-loop-1a-baseline-nopipe}
    \centering
    \input{report/float-loop-1a-baseline-nopipe.tex}
\end{table}


\begin{table}
    \caption{Performance and utilization estimates for \texttt{mmult\_float}}\label{tab:float-summary}
    \input{report/float-summary.tex}
\end{table}

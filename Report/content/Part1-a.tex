%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Understanding the baseline matrix multiply (background)}\label{sec:1a}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For Vitis 2020.2, the command used should be
\begin{minted}{console}
    $ vitis_hls -f hls.tcl
\end{minted}
The loop details report generated by HLS (as in \autoref{tab:float-loop-1a-baseline-autopipe}) shows that some pipelining has already been done automatically by Vitis HLS.
After inspecting the migration guide, I added two lines in the \texttt{hls.tcl}:
\begin{minted}{tcl}
    config_compile -pipeline_loops 0
    set_clock_uncertainty 12.5%
\end{minted}

The performance and utilization estimates of the two profiles, together with those for the following profiles, are reported in \autoref{tab:float-summary}.
The new loop details is as \autoref{tab:float-loop-1a-baseline-nopipe}.
It turns out that the overall performance is a little bit worse than documented.
This is because every iteration in L3 loop takes 11 cycles and thus
2816 cycles in total to perform a single inner product.

The overall latency of the baseline is 228022 cycles.
Since it only predicts on a batch of 8 inputs, the normalized latency is 28502.75 cycles.

\begin{table}[ht!]

    \caption{Loop details for baseline}

    \begin{subtable}{\textwidth}
        \caption{Baseline with automatic pipelining}
        \label{tab:float-loop-1a-baseline-autopipe}
        \centering
        \input{report/float-loop-1a-baseline-autopipe.tex}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \caption{Baseline without automatic pipelining}
        \label{tab:float-loop-1a-baseline-nopipe}
        \centering
        \input{report/float-loop-1a-baseline-nopipe.tex}
    \end{subtable}

\end{table}

\begin{table}
    \caption{Performance and utilization estimates for \texttt{mmult\_float}}\label{tab:float-summary}
    \input{report/float-summary.tex}
\end{table}
